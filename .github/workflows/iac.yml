# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Infrastructure as Code Pipeline - Multi-Environment AKS Deployment
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# This workflow handles:
# - OpenTofu validation and formatting
# - Auto-versioning modules with semantic versioning on merge to main
# - Plan/apply for dev, stg, prd environments
# - Branch-based deployment (push to dev/stg/prd branch)
#
# Module Versioning Strategy:
# - Modules are tagged as infra/{module}/v{major}.{minor}.{patch}
# - Version bumps follow conventional commits:
#   - feat: = minor bump
#   - fix: = patch bump
#   - BREAKING CHANGE or feat!: = major bump
#
# Environments:
# - dev: Development environment (branch: dev)
# - stg: Staging environment (branch: stg)  
# - prd: Production environment (branch: prd)
#
# Required GitHub Secrets (per environment):
# - ARM_CLIENT_ID: Azure Service Principal Client ID
# - ARM_CLIENT_SECRET: Azure Service Principal Client Secret
# - ARM_SUBSCRIPTION_ID: Azure Subscription ID
# - ARM_TENANT_ID: Azure AD Tenant ID
# - STATE_ACCESS_KEY: Azure Storage Account access key for tfstate
#
# Deploy Commands:
# - Plan only: Push to branch
# - Apply: Push with [tfapply] in commit message
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Infrastructure as Code

on:
  # Branch-based deployment
  push:
    branches:
      - dev
      - stg
      - prd
      - main
    paths:
      - '*.tf'
      - 'modules/**'
      - 'environments/**'
      - '.github/workflows/iac.yml'
  
  # PR validation (plans against dev)
  pull_request:
    branches: [dev, main]
    paths:
      - '*.tf'
      - 'modules/**'
      - 'environments/**'
      - '.github/workflows/iac.yml'
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - stg
          - prd
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply

concurrency:
  group: iac-${{ github.event.inputs.environment || github.ref_name }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  TOFU_VERSION: '1.6.0'
  WORKING_DIR: '.'
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# JOBS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Determine Environment
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Determine Environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            ENV="dev"
          else
            BRANCH="${{ github.ref_name }}"
            # Map branch to environment (main and feature branches default to dev)
            case "$BRANCH" in
              dev|stg|prd) ENV="$BRANCH" ;;
              main)        ENV="dev" ;;  # main branch deploys to dev
              *)           ENV="dev" ;;  # Feature branches use dev environment
            esac
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "ğŸ¯ Target environment: $ENV"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Detect Changed Modules
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      modules: ${{ steps.changes.outputs.modules }}
      modules_list: ${{ steps.changes.outputs.modules_list }}
      any_module_changed: ${{ steps.changes.outputs.any_module_changed }}
      stack_changed: ${{ steps.changes.outputs.stack_changed }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed modules
        id: changes
        run: |
          # Determine base commit for diff
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
              BASE_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "${{ github.sha }}")
            fi
          fi
          
          echo "Comparing $BASE_SHA to HEAD"
          
          # Find changed module directories
          CHANGED_MODULES=$(git diff --name-only "$BASE_SHA" HEAD -- 'modules/' 2>/dev/null | \
            grep '^modules/' | \
            cut -d'/' -f2 | \
            sort -u | \
            jq -R -s -c 'split("\n") | map(select(length > 0))' || echo '[]')
          
          # Check if root module files changed
          STACK_CHANGED=$(git diff --name-only "$BASE_SHA" HEAD -- \
            'main.tf' 'variables.tf' 'outputs.tf' \
            'providers.tf' 'environments/' 2>/dev/null | wc -l)
          
          echo "Changed modules: $CHANGED_MODULES"
          echo "Stack files changed: $STACK_CHANGED"
          
          echo "modules=$CHANGED_MODULES" >> $GITHUB_OUTPUT
          echo "modules_list=$(echo $CHANGED_MODULES | jq -r 'join(",")')" >> $GITHUB_OUTPUT
          
          if [[ "$CHANGED_MODULES" != "[]" && "$CHANGED_MODULES" != "" && "$CHANGED_MODULES" != "null" ]]; then
            echo "any_module_changed=true" >> $GITHUB_OUTPUT
          else
            echo "any_module_changed=false" >> $GITHUB_OUTPUT
          fi
          
          if [[ "$STACK_CHANGED" -gt 0 ]]; then
            echo "stack_changed=true" >> $GITHUB_OUTPUT
          else
            echo "stack_changed=false" >> $GITHUB_OUTPUT
          fi

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Validate OpenTofu
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  validate:
    name: Validate
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: Format Check
        working-directory: ${{ env.WORKING_DIR }}
        run: tofu fmt -check -recursive -diff

      - name: Initialize (validation only)
        working-directory: ${{ env.WORKING_DIR }}
        run: tofu init -backend=false

      - name: Validate
        working-directory: ${{ env.WORKING_DIR }}
        run: tofu validate

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Tag Modules on Merge (Auto-Versioning)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  tag-modules:
    name: Tag Module Versions
    runs-on: ubuntu-latest
    needs: [detect-changes, validate]
    if: |
      github.event_name == 'push' && 
      github.ref_name == 'dev' &&
      needs.detect-changes.outputs.any_module_changed == 'true' &&
      needs.validate.result == 'success'
    
    permissions:
      contents: write

    outputs:
      tagged_modules: ${{ steps.tag.outputs.tagged_modules }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Tag changed modules
        id: tag
        env:
          CHANGED_MODULES: ${{ needs.detect-changes.outputs.modules_list }}
        run: |
          TAGGED_MODULES=""
          IFS=',' read -ra MODULES <<< "$CHANGED_MODULES"
          
          for module in "${MODULES[@]}"; do
            if [[ -z "$module" ]]; then
              continue
            fi
            
            # Map module directory to tag prefix
            case "$module" in
              azurerm-aks-tf)       TAG_PREFIX="infra/aks" ;;
              helm-postgres-tf)     TAG_PREFIX="infra/postgres" ;;
              helm-kafka-tf)        TAG_PREFIX="infra/kafka" ;;
              *)                    TAG_PREFIX="infra/${module%-tf}" ;;
            esac
            
            # Get latest version tag for this module
            LATEST_TAG=$(git tag -l "${TAG_PREFIX}/v*" | sort -V | tail -1)
            
            if [[ -z "$LATEST_TAG" ]]; then
              # First version
              NEW_VERSION="v1.0.0"
              COMPARE_REF="HEAD~10"
            else
              COMPARE_REF="$LATEST_TAG"
              
              # Extract version components
              VERSION=${LATEST_TAG##*/}
              MAJOR=$(echo "$VERSION" | cut -d. -f1 | tr -d 'v')
              MINOR=$(echo "$VERSION" | cut -d. -f2)
              PATCH=$(echo "$VERSION" | cut -d. -f3)
              
              # Get commits affecting this module since last tag
              COMMITS=$(git log --oneline "$LATEST_TAG"..HEAD -- "modules/$module" 2>/dev/null || echo "")
              
              if [[ -z "$COMMITS" ]]; then
                echo "No commits found for $module since $LATEST_TAG, skipping"
                continue
              fi
              
              # Determine version bump from conventional commits
              if echo "$COMMITS" | grep -qiE "(BREAKING CHANGE|^[a-f0-9]+ [a-z]+(\([^)]+\))?!:)"; then
                NEW_VERSION="v$((MAJOR + 1)).0.0"
                BUMP_REASON="BREAKING CHANGE"
              elif echo "$COMMITS" | grep -qiE "^[a-f0-9]+ feat(\([^)]+\))?:"; then
                NEW_VERSION="v${MAJOR}.$((MINOR + 1)).0"
                BUMP_REASON="feat"
              else
                NEW_VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
                BUMP_REASON="fix/chore"
              fi
              
              echo "Version bump for $module: $VERSION -> $NEW_VERSION (reason: $BUMP_REASON)"
            fi
            
            NEW_TAG="${TAG_PREFIX}/${NEW_VERSION}"
            
            # Generate changelog for tag message
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" "$COMPARE_REF"..HEAD -- "modules/$module" 2>/dev/null | head -20)
            
            TAG_MESSAGE="Release $module $NEW_VERSION

          Changes:
          $CHANGELOG"
            
            echo "Creating tag: $NEW_TAG"
            git tag -a "$NEW_TAG" -m "$TAG_MESSAGE"
            git push origin "$NEW_TAG"
            
            echo "âœ… Tagged $module as $NEW_TAG"
            TAGGED_MODULES="${TAGGED_MODULES}${module}:${NEW_TAG},"
          done
          
          echo "tagged_modules=${TAGGED_MODULES%,}" >> $GITHUB_OUTPUT

      - name: Summary
        run: |
          echo "## ğŸ·ï¸ Module Tags Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          IFS=',' read -ra TAGS <<< "${{ steps.tag.outputs.tagged_modules }}"
          for tag_info in "${TAGS[@]}"; do
            if [[ -n "$tag_info" ]]; then
              MODULE=$(echo "$tag_info" | cut -d: -f1)
              TAG=$(echo "$tag_info" | cut -d: -f2)
              echo "- **$MODULE**: \`$TAG\`" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Use these tags in your root module:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`hcl" >> $GITHUB_STEP_SUMMARY
          echo "module \"azurerm-aks\" {" >> $GITHUB_STEP_SUMMARY
          echo "  source = \"git::https://github.com/${{ github.repository }}.git//modules/azurerm-aks-tf?ref=infra/aks/vX.Y.Z\"" >> $GITHUB_STEP_SUMMARY
          echo "}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Plan Infrastructure
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  plan:
    name: Plan [${{ needs.setup.outputs.environment }}]
    runs-on: ubuntu-latest
    needs: [setup, validate]
    if: needs.validate.result == 'success'
    environment: ${{ needs.setup.outputs.environment }}
    
    permissions:
      contents: read
      pull-requests: write

    outputs:
      plan_exit_code: ${{ steps.plan.outputs.exitcode }}

    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: Initialize OpenTofu
        working-directory: ${{ env.WORKING_DIR }}
        env:
          ARM_ACCESS_KEY: ${{ secrets.STATE_ACCESS_KEY }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          echo "Initializing for environment: $ENV"
          tofu init \
            -backend-config="resource_group_name=iac" \
            -backend-config="storage_account_name=stiacstate${ENV}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${ENV}/terraform.tfstate"

      - name: Install tf-summarize
        run: |
          curl -sSL https://github.com/dineshba/tf-summarize/releases/download/v0.3.10/tf-summarize_linux_amd64.tar.gz | tar xz
          sudo mv tf-summarize /usr/local/bin/

      - name: Plan OpenTofu
        id: plan
        working-directory: ${{ env.WORKING_DIR }}
        continue-on-error: true
        run: |
          set +e
          ENV="${{ needs.setup.outputs.environment }}"
          
          tofu plan \
            -var-file="environments/${ENV}.tfvars" \
            -out=tfplan-${ENV} \
            -detailed-exitcode \
            -no-color 2>&1 | tee plan-output.txt
          
          EXIT_CODE=$?
          echo "exitcode=$EXIT_CODE" >> $GITHUB_OUTPUT
          
          # Generate JSON plan for tf-summarize
          if [[ $EXIT_CODE -ne 1 ]]; then
            tofu show -json tfplan-${ENV} > tfplan-${ENV}.json 2>/dev/null || true
          fi
          
          if [[ $EXIT_CODE -eq 1 ]]; then
            echo "âŒ Plan failed"
            exit 1
          fi

      - name: Generate Plan Summary
        if: always()
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          EXIT_CODE="${{ steps.plan.outputs.exitcode }}"
          
          # Status emoji and message
          if [[ "$EXIT_CODE" == "0" ]]; then
            STATUS="âœ… No Changes"
            EMOJI="white_check_mark"
          elif [[ "$EXIT_CODE" == "2" ]]; then
            STATUS="âš ï¸ Changes Detected"
            EMOJI="warning"
          else
            STATUS="âŒ Plan Failed"
            EMOJI="x"
          fi
          
          echo "## ğŸ—ï¸ OpenTofu Plan: \`${ENV}\` - ${STATUS}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add tf-summarize output if plan succeeded
          if [[ -f "tfplan-${ENV}.json" ]]; then
            echo "### ğŸ“Š Resource Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            tf-summarize -md tfplan-${ENV}.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Extract key metrics from plan output
          ADDS=$(grep -oP 'Plan: \K\d+(?= to add)' plan-output.txt 2>/dev/null || echo "0")
          CHANGES=$(grep -oP ', \K\d+(?= to change)' plan-output.txt 2>/dev/null || echo "0")
          DESTROYS=$(grep -oP ', \K\d+(?= to destroy)' plan-output.txt 2>/dev/null || echo "0")
          
          echo "### ğŸ“ˆ Change Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Action | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸŸ¢ Add | ${ADDS} |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸŸ¡ Change | ${CHANGES} |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸ”´ Destroy | ${DESTROYS} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Full plan in collapsible section
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary>ğŸ“œ Full Plan Output (click to expand)</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```hcl' >> $GITHUB_STEP_SUMMARY
          cat plan-output.txt >> $GITHUB_STEP_SUMMARY || true
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

      - name: Create plan metadata
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          cat > tfplan-${ENV}.meta.json << EOF
          {
            "commit_sha": "${{ github.sha }}",
            "environment": "${ENV}",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "created_by": "${{ github.actor }}",
            "workflow_run_id": "${{ github.run_id }}",
            "has_changes": ${{ steps.plan.outputs.exitcode == '2' && 'true' || 'false' }}
          }
          EOF

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ needs.setup.outputs.environment }}-${{ github.run_id }}
          path: |
            ${{ env.WORKING_DIR }}/tfplan-${{ needs.setup.outputs.environment }}
            ${{ env.WORKING_DIR }}/tfplan-${{ needs.setup.outputs.environment }}.json
            ${{ env.WORKING_DIR }}/tfplan-${{ needs.setup.outputs.environment }}.meta.json
            ${{ env.WORKING_DIR }}/plan-output.txt
          retention-days: 7

      - name: Comment Plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          PLAN_OUTPUT: ${{ env.WORKING_DIR }}/plan-output.txt
          PLAN_EXIT_CODE: ${{ steps.plan.outputs.exitcode }}
          ENV_NAME: ${{ needs.setup.outputs.environment }}
        with:
          script: |
            const fs = require('fs');
            const env = process.env.ENV_NAME;
            const exitCode = process.env.PLAN_EXIT_CODE;
            let planOutput = '';
            try {
              planOutput = fs.readFileSync(process.env.PLAN_OUTPUT, 'utf8');
            } catch (e) {
              planOutput = 'Unable to read plan output';
            }
            const addMatch = planOutput.match(/Plan: (\d+) to add/);
            const changeMatch = planOutput.match(/(\d+) to change/);
            const destroyMatch = planOutput.match(/(\d+) to destroy/);
            const adds = addMatch ? addMatch[1] : '0';
            const changes = changeMatch ? changeMatch[1] : '0';
            const destroys = destroyMatch ? destroyMatch[1] : '0';
            let status = 'âœ… No Changes';
            if (exitCode === '2') status = 'âš ï¸ Changes Detected';
            if (exitCode === '1') status = 'âŒ Plan Failed';
            const truncated = planOutput.length > 50000 ? planOutput.substring(0, 50000) + '\n\n... (truncated)' : planOutput;
            const body = '## ğŸ—ï¸ OpenTofu Plan: `' + env + '` ' + status + '\n\n' +
              '### ğŸ“ˆ Change Summary\n\n' +
              '| Action | Count |\n|--------|-------|\n' +
              '| ğŸŸ¢ Add | ' + adds + ' |\n' +
              '| ğŸŸ¡ Change | ' + changes + ' |\n' +
              '| ğŸ”´ Destroy | ' + destroys + ' |\n\n' +
              '<details>\n<summary>ğŸ“œ Full Plan Output</summary>\n\n```hcl\n' + truncated + '\n```\n\n</details>\n\n' +
              '---\nğŸ“ Commit: `${{ github.sha }}`\nğŸ”— [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})';
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number
            });
            const botComment = comments.find(c => c.user.login === 'github-actions[bot]' && c.body.includes('OpenTofu Plan:'));
            if (botComment) {
              await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: botComment.id, body: body });
            } else {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, body: body });
            }

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Apply Infrastructure
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  apply:
    name: Apply [${{ needs.setup.outputs.environment }}]
    runs-on: ubuntu-latest
    needs: [setup, plan]
    if: |
      needs.plan.result == 'success' &&
      ((github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
       (github.event_name == 'push' && contains(github.event.head_commit.message, '[tfapply]')))
    
    environment: 
      name: ${{ needs.setup.outputs.environment }}
      url: https://portal.azure.com
    
    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ needs.setup.outputs.environment }}-${{ github.run_id }}
          path: ${{ env.WORKING_DIR }}

      - name: Verify Plan Freshness
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          
          if [[ ! -f "tfplan-${ENV}.meta.json" ]]; then
            echo "âŒ Plan metadata not found."
            exit 1
          fi
          
          PLAN_SHA=$(jq -r '.commit_sha' "tfplan-${ENV}.meta.json")
          
          echo "Plan commit: $PLAN_SHA"
          echo "Current commit: ${{ github.sha }}"
          
          if [[ "$PLAN_SHA" != "${{ github.sha }}" ]]; then
            echo "âŒ Plan is STALE. Re-run with action=plan first."
            exit 1
          fi
          
          echo "âœ… Plan is fresh"

      - name: Initialize OpenTofu
        working-directory: ${{ env.WORKING_DIR }}
        env:
          ARM_ACCESS_KEY: ${{ secrets.STATE_ACCESS_KEY }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          tofu init \
            -backend-config="resource_group_name=iac" \
            -backend-config="storage_account_name=stiacstate${ENV}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${ENV}/terraform.tfstate"

      - name: Apply OpenTofu
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          echo "ğŸš€ Applying infrastructure changes to ${ENV}..."
          tofu apply -auto-approve tfplan-${ENV}

      - name: Summary
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          echo "## âœ… Apply Completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${ENV}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Applied by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Quality Gate
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: [setup, validate, plan]
    if: always()

    steps:
      - name: Evaluate Results
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          echo "## IaC Quality Gate Results [$ENV]" >> $GITHUB_STEP_SUMMARY
          
          FAILED=false
          
          if [[ "${{ needs.validate.result }}" == "success" ]]; then
            echo "âœ… Validation passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Validation failed" >> $GITHUB_STEP_SUMMARY
            FAILED=true
          fi
          
          if [[ "${{ needs.plan.result }}" == "success" ]]; then
            echo "âœ… OpenTofu plan succeeded" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ OpenTofu plan failed" >> $GITHUB_STEP_SUMMARY
            FAILED=true
          fi
          
          if [[ "$FAILED" == "true" ]]; then
            echo "### âŒ Quality Gate Failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "### âœ… All Quality Gates Passed" >> $GITHUB_STEP_SUMMARY
          fi
