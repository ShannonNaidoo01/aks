# ==============================================================================
# Infrastructure as Code Pipeline - Multi-Stack Deployment
# ==============================================================================
#
# Stacks:
# - core: AKS cluster, ingress-nginx, cert-manager, cluster-test, entra-groups
# - postgres-svr: PostgreSQL operator + server (environment scope)
# - postgres-db: Individual databases (application scope)
#
# State Files:
# - Storage Account: txstate{env}
# - Container: {stack-name}
# - Key: {env}/terraform.tfstate (env-scope)
# - Key: {env}/{app}/terraform.tfstate (app-scope like postgres-db)
#
# Branching:
# - dev/stg/prd branches -> deploy to matching environment
# - main branch -> deploys to dev
#
# Deploy Commands:
# - Plan only: Push to branch
# - Apply: Push with [tfapply] in commit message, or use workflow_dispatch
#
# ==============================================================================

name: Infrastructure as Code

on:
  push:
    branches:
      - dev
      - stg
      - prd
      - main
    paths:
      - 'stacks/**'
      - 'modules/**'
      - '.github/workflows/iac.yml'

  pull_request:
    branches: [dev, main]
    paths:
      - 'stacks/**'
      - 'modules/**'
      - '.github/workflows/iac.yml'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - stg
          - prd
      stack:
        description: 'Stack to deploy'
        required: true
        default: 'core'
        type: choice
        options:
          - core
          - postgres-svr
          - postgres-db
          - all
      app_name:
        description: 'App name (required for postgres-db, e.g., app1, app2)'
        required: false
        default: ''
        type: string
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply

concurrency:
  group: iac-${{ github.event.inputs.stack || 'auto' }}-${{ github.event.inputs.app_name || 'default' }}-${{ github.event.inputs.environment || github.ref_name }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  TOFU_VERSION: '1.6.0'
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

jobs:
  # ============================================================================
  # Setup: Determine environment and detect changed stacks
  # ============================================================================
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      app_name: ${{ steps.set-env.outputs.app_name }}
      stacks: ${{ steps.detect-stacks.outputs.stacks }}
      stacks_count: ${{ steps.detect-stacks.outputs.stacks_count }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
            APP_NAME="${{ github.event.inputs.app_name }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            ENV="dev"
            APP_NAME=""
          else
            BRANCH="${{ github.ref_name }}"
            case "$BRANCH" in
              dev|stg|prd) ENV="$BRANCH" ;;
              main)        ENV="dev" ;;
              *)           ENV="dev" ;;
            esac
            APP_NAME=""
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "ðŸŽ¯ Target environment: $ENV"
          if [[ -n "$APP_NAME" ]]; then
            echo "ðŸŽ¯ App name: $APP_NAME"
          fi

      - name: Detect Changed Stacks
        id: detect-stacks
        run: |
          ENV="${{ steps.set-env.outputs.environment }}"
          APP_NAME="${{ steps.set-env.outputs.app_name }}"
          
          # Manual trigger with specific stack
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            STACK="${{ github.event.inputs.stack }}"
            
            if [[ "$STACK" == "all" ]]; then
              # For 'all', we only do env-scope stacks
              STACKS='[{"name":"core","app":""},{"name":"postgres-svr","app":""}]'
            elif [[ "$STACK" == "postgres-db" ]]; then
              # postgres-db requires app_name
              if [[ -z "$APP_NAME" ]]; then
                echo "âŒ Error: postgres-db requires app_name"
                echo "stacks=[]" >> $GITHUB_OUTPUT
                echo "stacks_count=0" >> $GITHUB_OUTPUT
                exit 0
              fi
              STACKS="[{\"name\":\"postgres-db\",\"app\":\"$APP_NAME\"}]"
            else
              STACKS="[{\"name\":\"$STACK\",\"app\":\"\"}]"
            fi
            echo "stacks=$STACKS" >> $GITHUB_OUTPUT
            echo "stacks_count=$(echo $STACKS | jq length)" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Manual trigger for stack(s): $STACKS"
            exit 0
          fi
          
          # Auto-detect changed stacks
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
              BASE_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "${{ github.sha }}")
            fi
          fi
          
          echo "Comparing $BASE_SHA to HEAD"
          
          # Find changed stacks (excluding postgres-db for auto-detect)
          CHANGED_STACKS=$(git diff --name-only "$BASE_SHA" HEAD -- 'stacks/' 2>/dev/null | \
            grep '^stacks/' | \
            cut -d'/' -f2 | \
            grep -v 'postgres-db' | \
            sort -u || echo "")
          
          # Check if modules changed (affects env-scope stacks)
          MODULES_CHANGED=$(git diff --name-only "$BASE_SHA" HEAD -- 'modules/' 2>/dev/null | wc -l)
          
          if [[ "$MODULES_CHANGED" -gt 0 ]]; then
            echo "Modules changed - including env-scope stacks"
            CHANGED_STACKS="core postgres-svr"
          fi
          
          if [[ -z "$CHANGED_STACKS" ]]; then
            echo "No stacks changed"
            echo "stacks=[]" >> $GITHUB_OUTPUT
            echo "stacks_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Build JSON array (env-scope stacks only for auto-detect)
          STACKS_JSON="["
          FIRST=true
          for stack in $CHANGED_STACKS; do
            if [[ -d "stacks/$stack" ]]; then
              if [[ "$FIRST" != "true" ]]; then
                STACKS_JSON="$STACKS_JSON,"
              fi
              STACKS_JSON="$STACKS_JSON{\"name\":\"$stack\",\"app\":\"\"}"
              FIRST=false
            fi
          done
          STACKS_JSON="$STACKS_JSON]"
          
          echo "stacks=$STACKS_JSON" >> $GITHUB_OUTPUT
          echo "stacks_count=$(echo $STACKS_JSON | jq length)" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Changed stacks: $STACKS_JSON"

  # ============================================================================
  # Validate: Format and syntax check
  # ============================================================================
  validate:
    name: Validate
    runs-on: ubuntu-latest
    needs: [setup]
    if: needs.setup.outputs.stacks_count != '0'

    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: Format Check
        run: tofu fmt -check -recursive -diff

      - name: Validate Stacks
        run: |
          STACKS='${{ needs.setup.outputs.stacks }}'
          
          for row in $(echo "$STACKS" | jq -r '.[] | @base64'); do
            STACK=$(echo "$row" | base64 --decode | jq -r '.name')
            
            if [[ -d "stacks/$STACK" ]]; then
              echo "ðŸ“¦ Validating stack: $STACK"
              cd "stacks/$STACK"
              tofu init -backend=false
              tofu validate
              cd ../..
            fi
          done

  # ============================================================================
  # Plan: Generate plan for each stack
  # ============================================================================
  plan:
    name: Plan
    runs-on: ubuntu-latest
    needs: [setup, validate]
    if: needs.validate.result == 'success' && needs.setup.outputs.stacks_count != '0'
    environment: ${{ needs.setup.outputs.environment }}

    permissions:
      contents: read
      pull-requests: write

    outputs:
      plans: ${{ steps.plan-all.outputs.plans }}

    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: Plan All Stacks
        id: plan-all
        env:
          ARM_ACCESS_KEY: ${{ secrets.STATE_ACCESS_KEY }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          STACKS='${{ needs.setup.outputs.stacks }}'
          PLANS_RESULT="[]"
          ALL_SUCCESS=true
          
          mkdir -p plan-artifacts
          
          echo "## ðŸ—ï¸ OpenTofu Plans for \`${ENV}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          for row in $(echo "$STACKS" | jq -r '.[] | @base64'); do
            STACK=$(echo "$row" | base64 --decode | jq -r '.name')
            APP=$(echo "$row" | base64 --decode | jq -r '.app')
            
            if [[ ! -d "stacks/$STACK" ]]; then
              echo "âš ï¸ Stack directory not found: stacks/$STACK"
              continue
            fi
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸ“¦ Planning stack: $STACK"
            if [[ -n "$APP" && "$APP" != "null" && "$APP" != "" ]]; then
              echo "ðŸ“¦ App: $APP"
            fi
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            cd "stacks/$STACK"
            
            # Determine tfvars and state key based on app-scope or env-scope
            if [[ -n "$APP" && "$APP" != "null" && "$APP" != "" ]]; then
              # App-scope (e.g., postgres-db)
              TFVARS_FILE="environments/${ENV}-${APP}.tfvars"
              STATE_KEY="${ENV}/${APP}/terraform.tfstate"
              PLAN_NAME="tfplan-${STACK}-${ENV}-${APP}"
            else
              # Env-scope (e.g., core, postgres-svr)
              TFVARS_FILE="environments/${ENV}.tfvars"
              STATE_KEY="${ENV}/terraform.tfstate"
              PLAN_NAME="tfplan-${STACK}-${ENV}"
            fi
            
            # Check if tfvars exists
            if [[ ! -f "$TFVARS_FILE" ]]; then
              echo "âš ï¸ tfvars not found: $TFVARS_FILE - skipping"
              cd ../..
              continue
            fi
            
            # Initialize
            echo "Initializing with state: container=$STACK, key=$STATE_KEY"
            tofu init \
              -backend-config="resource_group_name=iac" \
              -backend-config="storage_account_name=txstate${ENV}" \
              -backend-config="container_name=${STACK}" \
              -backend-config="key=${STATE_KEY}"
            
            # Plan
            set +e
            tofu plan \
              -var-file="$TFVARS_FILE" \
              -out="$PLAN_NAME" \
              -detailed-exitcode \
              -no-color 2>&1 | tee "plan-output.txt"
            
            EXIT_CODE=$?
            set -e
            
            # Parse metrics
            ADDS=$(grep -oP 'Plan: \K\d+(?= to add)' plan-output.txt 2>/dev/null || echo "0")
            CHANGES=$(grep -oP ', \K\d+(?= to change)' plan-output.txt 2>/dev/null || echo "0")
            DESTROYS=$(grep -oP ', \K\d+(?= to destroy)' plan-output.txt 2>/dev/null || echo "0")
            
            # Status
            if [[ $EXIT_CODE -eq 0 ]]; then
              STATUS="âœ… No Changes"
            elif [[ $EXIT_CODE -eq 2 ]]; then
              STATUS="âš ï¸ Changes Detected"
            else
              STATUS="âŒ Failed"
              ALL_SUCCESS=false
            fi
            
            # Summary
            DISPLAY_NAME="$STACK"
            if [[ -n "$APP" && "$APP" != "null" && "$APP" != "" ]]; then
              DISPLAY_NAME="${STACK}/${APP}"
            fi
            
            echo "### ðŸ“¦ Stack: \`$DISPLAY_NAME\` - $STATUS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Action | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸŸ¢ Add | $ADDS |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸŸ¡ Change | $CHANGES |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ”´ Destroy | $DESTROYS |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Metadata
            echo "{\"commit_sha\":\"${{ github.sha }}\",\"environment\":\"${ENV}\",\"stack\":\"${STACK}\",\"app\":\"${APP}\",\"exit_code\":${EXIT_CODE},\"has_changes\":$([ $EXIT_CODE -eq 2 ] && echo 'true' || echo 'false')}" > "${PLAN_NAME}.meta.json"
            
            # Copy artifacts
            cp "$PLAN_NAME" "../../plan-artifacts/" 2>/dev/null || true
            cp "${PLAN_NAME}.meta.json" "../../plan-artifacts/" 2>/dev/null || true
            cp "plan-output.txt" "../../plan-artifacts/${PLAN_NAME}-output.txt" 2>/dev/null || true
            
            PLANS_RESULT=$(echo "$PLANS_RESULT" | jq ". + [{\"stack\":\"$STACK\",\"app\":\"$APP\",\"exit_code\":$EXIT_CODE}]")
            
            cd ../..
          done
          
          echo "plans=$(echo $PLANS_RESULT | jq -c)" >> $GITHUB_OUTPUT
          
          if [[ "$ALL_SUCCESS" != "true" ]]; then
            echo "âŒ One or more plans failed"
            exit 1
          fi

      - name: Upload Plan Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tfplans-${{ needs.setup.outputs.environment }}-${{ github.run_id }}
          path: plan-artifacts/
          retention-days: 7

      - name: Comment Plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          ENV: ${{ needs.setup.outputs.environment }}
          PLANS: ${{ steps.plan-all.outputs.plans }}
        with:
          script: |
            const env = process.env.ENV;
            const plans = JSON.parse(process.env.PLANS || '[]');
            
            let body = '## ðŸ—ï¸ OpenTofu Plans for `' + env + '`\n\n';
            body += '| Stack | Status |\n|-------|--------|\n';
            
            for (const plan of plans) {
              const status = plan.exit_code === 0 ? 'âœ… No Changes' : 
                            plan.exit_code === 2 ? 'âš ï¸ Changes' : 'âŒ Failed';
              const name = plan.app ? plan.stack + '/' + plan.app : plan.stack;
              body += '| ' + name + ' | ' + status + ' |\n';
            }
            
            body += '\n---\nðŸ“ Commit: `${{ github.sha }}`';
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const botComment = comments.find(c => 
              c.user.login === 'github-actions[bot]' && 
              c.body.includes('OpenTofu Plans')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  # ============================================================================
  # Apply: Apply plans for each stack
  # ============================================================================
  apply:
    name: Apply
    runs-on: ubuntu-latest
    needs: [setup, plan]
    if: |
      needs.plan.result == 'success' &&
      ((github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
       (github.event_name == 'push' && contains(github.event.head_commit.message, '[tfapply]')))

    environment:
      name: ${{ needs.setup.outputs.environment }}
      url: https://portal.azure.com

    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.TOFU_VERSION }}

      - name: Download Plans
        uses: actions/download-artifact@v4
        with:
          name: tfplans-${{ needs.setup.outputs.environment }}-${{ github.run_id }}
          path: plan-artifacts

      - name: Apply All Stacks
        env:
          ARM_ACCESS_KEY: ${{ secrets.STATE_ACCESS_KEY }}
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          STACKS='${{ needs.setup.outputs.stacks }}'
          
          echo "## ðŸš€ Applying Infrastructure to \`${ENV}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          for row in $(echo "$STACKS" | jq -r '.[] | @base64'); do
            STACK=$(echo "$row" | base64 --decode | jq -r '.name')
            APP=$(echo "$row" | base64 --decode | jq -r '.app')
            
            if [[ ! -d "stacks/$STACK" ]]; then
              continue
            fi
            
            # Determine plan name and state key
            if [[ -n "$APP" && "$APP" != "null" && "$APP" != "" ]]; then
              PLAN_NAME="tfplan-${STACK}-${ENV}-${APP}"
              STATE_KEY="${ENV}/${APP}/terraform.tfstate"
              DISPLAY_NAME="${STACK}/${APP}"
            else
              PLAN_NAME="tfplan-${STACK}-${ENV}"
              STATE_KEY="${ENV}/terraform.tfstate"
              DISPLAY_NAME="$STACK"
            fi
            
            # Check plan exists and is fresh
            if [[ ! -f "plan-artifacts/${PLAN_NAME}.meta.json" ]]; then
              echo "âš ï¸ Plan not found for $DISPLAY_NAME, skipping"
              continue
            fi
            
            PLAN_SHA=$(jq -r '.commit_sha' "plan-artifacts/${PLAN_NAME}.meta.json")
            HAS_CHANGES=$(jq -r '.has_changes' "plan-artifacts/${PLAN_NAME}.meta.json")
            
            if [[ "$PLAN_SHA" != "${{ github.sha }}" ]]; then
              echo "âŒ Plan for $DISPLAY_NAME is stale"
              exit 1
            fi
            
            if [[ "$HAS_CHANGES" != "true" ]]; then
              echo "- **$DISPLAY_NAME**: â­ï¸ Skipped (no changes)" >> $GITHUB_STEP_SUMMARY
              continue
            fi
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸš€ Applying stack: $DISPLAY_NAME"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            cp "plan-artifacts/${PLAN_NAME}" "stacks/$STACK/"
            
            cd "stacks/$STACK"
            
            tofu init \
              -backend-config="resource_group_name=iac" \
              -backend-config="storage_account_name=txstate${ENV}" \
              -backend-config="container_name=${STACK}" \
              -backend-config="key=${STATE_KEY}"
            
            tofu apply -auto-approve "$PLAN_NAME"
            
            echo "- **$DISPLAY_NAME**: âœ… Applied" >> $GITHUB_STEP_SUMMARY
            
            cd ../..
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Applied by: **${{ github.actor }}**" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Quality Gate
  # ============================================================================
  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: [setup, validate, plan]
    if: always() && needs.setup.outputs.stacks_count != '0'

    steps:
      - name: Evaluate Results
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          echo "## Quality Gate [$ENV]" >> $GITHUB_STEP_SUMMARY
          
          FAILED=false
          
          if [[ "${{ needs.validate.result }}" == "success" ]]; then
            echo "âœ… Validation passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Validation failed" >> $GITHUB_STEP_SUMMARY
            FAILED=true
          fi
          
          if [[ "${{ needs.plan.result }}" == "success" ]]; then
            echo "âœ… Plan succeeded" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Plan failed" >> $GITHUB_STEP_SUMMARY
            FAILED=true
          fi
          
          if [[ "$FAILED" == "true" ]]; then
            exit 1
          fi
